package minesweeper

import kotlin.random.Random

class Таблица {
    val ширинаМинногоПоля: Int
    val длиннаМинногоПоля: Int

    val полеСМинами: Array<IntArray>
    val исследованныеПоля: Array<IntArray>

    var количествоМин: Int = 0
    var количествоНеисследованныхПолей: Int

    var тыПобедил: Boolean
    var играОкончена: Boolean

    constructor (ширина: Int, высота: Int) {
        ширинаМинногоПоля = ширина
        длиннаМинногоПоля = высота
        полеСМинами = Array(длиннаМинногоПоля) { IntArray(ширинаМинногоПоля) }
        исследованныеПоля = Array(длиннаМинногоПоля) { IntArray(ширинаМинногоПоля) }
        количествоНеисследованныхПолей = ширинаМинногоПоля * длиннаМинногоПоля
        играОкончена = false
        тыПобедил = false
    }

    fun взятьЗначениеЭлемент(строка: Int, столбец: Int): Int = полеСМинами[строка][столбец]

    fun записатьЗначениеВЭлемент(строка: Int, столбец: Int, значение: Int) {
        полеСМинами[строка][столбец] = значение
    }

    fun закопатьМиныВСлучайныхМестах(количествоМин: Int) {
        while (this.количествоМин != количествоМин) {
            var мина = arrayOf(Random.nextInt(0, 9), Random.nextInt(0, 9))
            if (взятьЗначениеЭлемент(мина[0], мина[1]) != -1) {
                this.количествоМин++
                записатьЗначениеВЭлемент(мина[0], мина[1], -1)
                добавитьПодсказки(мина)
            }
        }
    }

    private fun добавитьПодсказки(мина: Array<Int>) {
        for (_Y in мина[0] - 1..мина[0] + 1) {
            if (_Y >= 0 && _Y < длиннаМинногоПоля) {
                for (_X in мина[1] - 1..мина[1] + 1) {
                    if (_X >= 0 && _X < ширинаМинногоПоля) {
                        добавитьПодсказкуКПолюРядомСКоторымЗакопалиМину(_Y, _X)
                    }
                }
            }
        }
    }

    private fun добавитьПодсказкуКПолюРядомСКоторымЗакопалиМину(_Y: Int, _X: Int) {
        if (взятьЗначениеЭлемент(_Y, _X) == -1) return
        записатьЗначениеВЭлемент(_Y, _X, взятьЗначениеЭлемент(_Y, _X) + 1)
    }

    fun отрисоватьНаЭкране() {
        var нарисовать =    " │123456789│\n" +
                        "—│—————————│\n"
        for (_Y in 0 until длиннаМинногоПоля) {
            нарисовать += "${_Y + 1}│"
            for (_X in 0 until ширинаМинногоПоля) {
                нарисовать += when (взятьЗначениеЭлемент(_Y, _X)) {
                    -1 -> if (играОкончена) "X"   // если ты это видишь, то ты проиграл
                          else "."              // если не проиграл, то пока мина не видна

                    -2, 10 -> "*"               // маркер на мине или на пустом поле

                    in 1..8 -> if (полеИсследовано(_Y, _X)) "."       // пока поле в тумане цифры не видны
                          else взятьЗначениеЭлемент(_Y, _X).toString()// если тумана нет - пишем количество мин вокруг

                    in 11..18 -> if (полеИсследовано(_Y, _X)) "*" // метка на поле с цифрой если туман есть
                          else {                        // если тумана нет (если такое возможно), то
                        записатьЗначениеВЭлемент(_Y, _X, взятьЗначениеЭлемент(_Y, _X) - 10)// снимаем метку и
                        взятьЗначениеЭлемент(_Y, _X).toString()                     // рисуем цифру
                          }
                    else -> if (полеИсследовано(_Y, _X)) "."  // обычное поле с туманом
                          else "/"                  // поле без тумана
                }
            }
            нарисовать += "│\n"
        }
        нарисовать += "—│—————————│\n"
        print(нарисовать)
    }

    private fun полеИсследовано(_Y: Int, _X: Int): Boolean = (исследованныеПоля[_Y][_X] == 0)

    fun исследоватьПолеИлиПоставитьМетку(полученныйОтвет: String): Boolean {
        val ответИгрока = полученныйОтвет.split(" ")
        val _X: Int = ответИгрока[0].toInt() - 1
        val _Y: Int = ответИгрока[1].toInt() - 1
        var чтоНадоДелать = if (ответИгрока.size < 3) "free"  // дефолтное значение для ручного тестирования
                       else ответИгрока[2]
        when(чтоНадоДелать) {
            "mine" -> пометитьМину(_Y, _X)
            "free" -> исследоватьПолеНаступивНаНего(_Y, _X)
            else -> return false
        }
        if (количествоНеисследованныхПолей == количествоМин) {
            тыПобедил = true
            проверитьУсловияПобеды()
        }
        return true
    }

    private fun пометитьМину(_Y: Int, _X: Int) {
        val поле = взятьЗначениеЭлемент(_Y, _X)
        when (поле) {
            -1 -> записатьЗначениеВЭлемент(_Y, _X, -2)    // пометить мину
            -2 -> записатьЗначениеВЭлемент(_Y, _X, -1)    // снять метку с мины
             0 -> записатьЗначениеВЭлемент(_Y, _X, 10)    // поставить метку на пустое мето
            10 -> записатьЗначениеВЭлемент(_Y, _X, 0)     // снять метку с пустого места
            in 1..8 -> записатьЗначениеВЭлемент(_Y, _X, поле + 10) // метка на цифре
            else    -> записатьЗначениеВЭлемент(_Y, _X, поле - 10) // снять с цифры метку
        }
    }

    private fun исследоватьПолеНаступивНаНего(_Y: Int, _X: Int) {
        val значениеПоля = взятьЗначениеЭлемент(_Y, _X)
        val координатыТекущегоПоля: Array<Int> = arrayOf(_Y, _X)
        when (значениеПоля) {
            -1 -> играОкончена = true     // подорвался
            in 1..8 -> {                // открываем цифру
                исследованныеПоля[_Y][_X] = 1
                количествоНеисследованныхПолей--    // уменьшаем счетчик тумана
            }
            in 10..18 -> {              // открываем поле с меткой (10) или поле с меткой на цифре (11..18)
                исследованныеПоля[_Y][_X] = 1
                количествоНеисследованныхПолей--
                записатьЗначениеВЭлемент(_Y, _X, значениеПоля - 10)
                исследоватьСоседниеПоля(координатыТекущегоПоля)        // открываем соседние поля, если они небыли до этого открыты
            }
            0 -> {                      // открываем пустое поле
                исследованныеПоля[_Y][_X] = 1
                количествоНеисследованныхПолей--
                исследоватьСоседниеПоля(координатыТекущегоПоля)        // открываем соседние поля
            }
            else -> {}
        }
    }

    private fun исследоватьСоседниеПоля(координатыТекущегоПоля: Array<Int>) {  // перебор всех фосьми полей вокруг данного
        for (_Y in координатыТекущегоПоля[0] - 1..координатыТекущегоПоля[0] + 1) {
            if (_Y >= 0 && _Y < длиннаМинногоПоля) {            // но если оно с краю - пропускаем
                for (_X in координатыТекущегоПоля[1] - 1..координатыТекущегоПоля[1] + 1) {
                    if (_X >= 0 && _X < ширинаМинногоПоля) {        // пропускаем если поле за границей
                        if (исследованныеПоля[_Y][_X] == 0) {    // если уже было открыто, то пропускаем
                            исследоватьПолеНаступивНаНего(_Y, _X)
                        }
                    }
                }
            }
        }
    }

    fun проверитьУсловияПобеды() {
        var счетчикМетокНаМинах = 0
        for (_Y in 0 until длиннаМинногоПоля) {
            for (_X in 0 until ширинаМинногоПоля) {
                if (взятьЗначениеЭлемент(_Y, _X) == -2) // метка на мине
                    счетчикМетокНаМинах++                 // подсчет меток
                if (взятьЗначениеЭлемент(_Y, _X) == 10) { // остались метки на пустых клетках
                    тыПобедил = false               // пока НЕ победа
                    return
                }
            }
        }
        if (счетчикМетокНаМинах == количествоМин) {    // если количество меток на минах = моличеству мин, значит они все помечены. Тут надо бы переписать, что главное чтоб неоткрытых мест не оставалось, а не угадывать где в тумане мины стоят, но (я устал) оно и так все тесты проходит в другом месте программы.
            тыПобедил = true                // победа
            играОкончена = true           // игра окончена
        }
    }

    fun поздравитьСОкончаниемИгры() {
        if (тыПобедил) println("Congratulations! You found all the mines!")
        else println("You stepped on a mine and failed!")
    }
}